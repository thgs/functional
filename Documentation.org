#+HEADER: `functional` package Documentation
-----

* Introduction

Drawing inspiration mainly from Haskell, this library is trying to replicate in
behaviour a lot of Haskell's functional structures.

This library is my own effort and journey into better understanding these
functional structures and explore their use in PHP. If you find any error,
theoretical or implementation related, do not hesitate to point it out.

* Contributing

The main idea driving the design is to have a public interface that is usable
and allows static analysis to infer types. Under the public interface it is
allowed to go to any length in design in order to satisfy the behaviour we are
targeting. Things from Haskell do not necessarily map directly to PHP due to
differences in capabilities offered. It is a fact we could re-implement the
entirety of Haskell in PHP in behaviour but judgement must be used to bring
things into perspective.

* Usage
** Maybe
A Maybe tries to replicate Haskell's data type Maybe. As per
definition it can be `Nothing` or `Just x` where x is any value.

To construct a `Maybe a` value you can:

#+begin_src php

  $maybe = new Maybe(new Just(123));
  $anotherMaybe = new Maybe(new Nothing());

  $actualValue = $maybe->getValue(); // returns Just 123, so you can match the type
  $anotherActualvalue = $anotherMaybe->getValue();  // returns Nothing for the same reason

#+end_src

The object itself is a generic implementation but static analysis
should be able to infer types, ie for the above it should be able to
infer that it is Maybe<int>.

TODO: See if that can work like that or user needs to extend Maybe to
get consistency from static analysis. (getValue())

~Maybe~ implements ~Functor~ so you can apply a function to the underlying
value, taking into account the Maybe logic (it will apply only when it
is Just).

#+begin_src php

  $maybe = new Maybe(new Just(123));
  $maybeTimes34 = $maybe->fmap(fn ($x) => $x * 34);
  $result = $maybeTimes34->getValue();  // returns a Just(4182)

  $maybe = new Maybe(new Nothing());
  $maybeTimes34 = $maybe->fmap(fn ($x) => $x * 34);
  $result = $maybeTimes34->getValue(); // returns a Nothing

#+end_src

Apart from this, ~Maybe~ implements ~Show~ and ~Eq~.

** Either
** Composition
Composition is a structure to help you compose two functions. It is an
abstraction to be used instead of manually composing and implements Functor.

To compose a function you need to apply a new function to the composition
through the Functor interface (fmap).

Calling the function inside the Composition is as easy as:

#+begin_src php

  $composition = new Composition(min(...));
  $result = $composition([2, 3, 4]); // returns 2

#+end_src

Composing a function becomes:

#+begin_src php

  $composition->fmap(fn ($x) => $x % 2);
  $result = $composition([2, 3, 4]); // returns 0, effectively computing: min([2,3,4]) % 2 

#+end_src

The idea is that you can keep on applying functions into the composition.

TODO: Ergonomics here, could also implement a ~__call~ magic function ? Or ~pipe()~
so that the user can keep adding functions one after the other?

** Typeclasses

Currently type classes have been implemented as an interface.

*** Functor

TODO: Add main part for FunctorInterface

Utility traits are provided to help proove that your implementation satisfies
Functor laws.  Example usage:

#+begin_src php

  use FunctorProof;

  public function testIsAFunctor(): void
  {
      $this->assertInstanceIsFunctor(
          new Maybe(new Just(5)),
          fn (int $x): bool => $x == 5,
          fn (bool $x): string => $x == true ? '100' : '500'
      );
  }
#+end_src

The first argument of ~assertInstanceIsFunctor()~ expects to receive your object
that implements ~FunctorInterface~.

The second and third arguments are two possible functions to check whether your
functor implementation is indeed associative.

TODO: What happens when the functor is not associative - expand.

*** Applicative
*** Monad
* References and Reading material

[[https://www.haskellforall.com/2012/09/the-functor-design-pattern.html][Functor design pattern - HaskellForAll]]

